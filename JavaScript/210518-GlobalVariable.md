# 전역 변수의 문제점

1. 변수의 생명 주기

- 지역 변수의 생명 주기

변수는 선언 시 생성되고 할당 시 값을 갖는다. 변수에는 생성되고 소멸되는 생명 주기가 있다.

변수는 자신이 선언된 위치에서 생성되고 소멸된다. 따라서 전역 변수는 애플리케이션 종료 시 소멸하고 함수 내에서 선언한 변수는 함수 종료 시 소멸한다. 이런 면에서 지역 변수는 함수의 생명 주기와 일치한다.

함수 몸체 내부에서 선언한 변수가 함수보다 오래 생존하는 경우가 간혹 있다. 변수가 소멸되는 시점은 값이 할당된 메모리가 해제되어 가용 메모리 풀로 들어가는 때이다. 이를 다른 말로 풀자면 렉시컬 환경이 해제될 때 까지이다. 따라서 함수 자체는 종료되어도 함수를 참조하는 곳이 있다면 해제되지 않는다.

자바스크립트에서 호이스팅은 해당 스코프 내에서 일어난다.

- 전역 변수 생명 주기

함수와 달리 전역 코드는 프로그램 실행 시 곧바로 해석된다. 별도의 진입점이 없다는 말과 동일하다.

> 진입점(entry point)
    C나 Java를 실행할 때 main함수가 실행되는데 이 때 main을 진입점이라 한다.

함수는 함수 몸체 종료시 종료되고 전역 코드의 경우 프로그램 종료 시 종료된다. var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 

> 전역 객체(global object)
    전역 객체는 코드가 실행되기 전에 생성되는 객체이다. 클라이언트 사이드 환경에선 window, 서버 사이드 환경에서는 global을 의미한다 ES11에선 globalThis로 통일되었다.
    전역 객체는 표준 빌트인 함수, var 키워드로 선언한 전역 변수와 함수를 프로퍼티로 갖는다. 환경에 따라 호스트 객체도 프로퍼티로 갖는다.

브라우저 환경에서 전역 객체는 window이며 창을 닫을 때 소멸한다. 

- 전역 변수의 문제점

`암묵적 결합`

전역 변수는 모든 코드가 참조할 수 있으므로 어디서든 상태가 변화할 가능성이 있다. 이런 경우 추적이 어려워져 코드의 가독성을 저해한다.

`긴 생명 주기`

전역 변수는 프로그램 시작부터 종료까지 메모리 리소스를 소비한다. 따라서 메모리 누수의 가능성이 있다. 또한 오동작을 할 가능성이 높아진다.

`스코프 체인 상에서 종점에 존재`

스코프 체인 상에서 종점에 존재하기 때문에 검색 시간이 지역 변수보다 오래 걸린다.

`네임스페이스 오염`

모든 파일에서 접근할 수 있기 때문에 의도치 않은 할당이나 선언이 일어날 수 있다.

3. 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수

함수 정의와 동시에 호출할 수 있고, 모든 코드가 지역 스코프 내에 있도록 할 수 있다.

- 네임스페이스 객체

전역에 네임스페이스 객체를 생성하고 사용하고 싶은 변수를 프로퍼티로 추가한다. 네임스페이스에 또 다른 네임스페이스 객체를 추가하여 게층적인 스코프를 만들어낼 수 있다. 하지만, 네임스페이스 객체 첫 선언은 전역 스코프 내이기 때문에 좋다고 볼 순 없다.

- 모듈 패턴

모듈 패턴은 관련된 함수와 기능을 즉시 실행 함수로 묶어놓은 것이다. 모듈 패턴은 자바스크립트의 클로저를 기반으로 동작한다.

캡슐화란 객체의 상태를 나타내는 프로퍼티와 메소드를 하나로 묶는 것이다. 이를 묶음으로서 객체의 특정 프로퍼티나 메서드를 감출 수 있어 정보 은닉이 가능하다.

다른 언어에선 private, public을 통해 접근 권한을 통제할 수 있다. 자바스크립트 경우 이런 키워드가 없다. 다만 외부와 통할 수 있는 프로퍼티를 퍼블릭 멤버, 그렇지 않은 경우 프라이빗 멤버로 구분한다.

- ES6 모듈

ES6 모듈 사용 시 전역 변수를 사용할 수 없다. ES6 모듈은 독자적인 파일 스코프를 가진다. 따라서 var를 선언해도 window나 global의 프로퍼티로 추가되지 않는다.

이 기능은 IE에서 사용하지 못하기 때문에 webpack과 같은 모듈 번들러가 쓰인다.

