# ES6 함수의 추가 기능

1. 함수의 구분

ES6 이전의 모든 함수는 생성자 함수로도 일반 함수로도 호출할 수 있다. 따라서 모든 함수가 callable이면서 constructor이다.

객체에 바인딩된 함수도 ES6 이전엔 생성자 함수로서 호출할 수 있다. 이는 불필요한 프로토타입 객체를 생성한다.

ES6에서는 함수를 사용 목적에 따라 세가지로 분류하였다.

|ES6 함수의 구분|constructor|prototype|super|arguments|
|--|:--:|:--:|:--:|:--:|
|일반 함수(Normal)|O|O|X|O|
|메서드(Method)|X|X|O|O|
|화살표 함수(Arrow)|X|X|X|X|

2. 메서드

ES6 사양에서 메서드는 축약 표현으로 정의된 함수만을 의미한다. 이들은 non-constructor이다. ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.

더불어 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor이다.

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부슬롯 `[[HomeObject]]`를 갖는다. 따라서 super참조를 이용할 수 있다.

ES6 메서드에서 super를 추가하고 constructor를 제거하였기 때문에 메서드를 정의할 때 익명 함수 표현식을 할당하는 것은 문맥상 지양해야한다.

3. 화살표 함수

- 화살표 함수 정의

+ 함수 정의

화살표 함수는 함수 선언문으로 정의할 수 없고 표현식으로 정의해야 한다.

+ 매개변수 선언

매개변수는 소괄호안에 콤마를 통해 구분하여 작성한다. 만약 매개변수가 한 개인 경우 소괄호를 생략한다.

+ 함수 몸체 정의

함수 몸체는 중괄호로 묶어서 나타낸다. 함수 몸체에서 (표현식인)문이 하나라면 중괄호를 생략할 수 있다. 이때 함수 몸체 내부문의 값이 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.

객체 리터럴을 반환하는 경우 블록문으로 해석될 수 있어 객체 리터럴을 소괄호로 감싸 주어야 한다. 

화살표 함수도 즉시 실행 함수로 사용할 수 있다.

화살표 함수도 일급 객체이므로 고차함수에 인수를 전달할 수 있다. 따라서 콜백 함수로서 정의할 때 유용하다.

- 화살표 함수와 일반 함수의 차이

+ 화살표 함수는 인스턴스는 생성할 수 없는 non-constructor이다.

따라서 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.

- 중복된 매개변수 이름을 선언할 수 없다.

strict mode가 아닌 일반함수에서는 매개변수의 중복을 허용한다. 

- 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. 따라서 이 프로퍼티들을 참조하면 스코프체인을 통해 상위 스코프에서 프로퍼티들을 찾는다. 

- this

일반 함수로서 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다. 하지만 strict mode가 적용되는 경우 undefined가 바인딩 되기 때문에 이 부분에 유의해야한다. 콜백 함수가 넘어오는 경우 오류를 일으킬 수 있기 때문이다.

ES6이전에 콜백 함수 내부의 this 문제를 해결하는 방법은 다음과 같다.

+ 메서드를 호출한 객체를 가리키는 this를 일단 회피시킨 후에 콜백 함수 내부에서 사용한다.

+ 콜백함수의 두번째 인수로 this를 전달한다.

+ bind 메서드를 사용하여 객체를 가르키는 this를 바인딩한다.

ES6에서는 화살표 함수를 사용하여 해결할 수 있다.

화살표 함수는 함수 자체의 this를 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.

만약 화살표 함수 간의 중첩이 있다면 이들에겐 this바인딩이 없으므로 스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 this를 참조한다.

화살표 함수는 자체 this 바인딩이 존재하지 않기 때문에 Function.prototype.call/apply/bind 메서드를 사용해도 화살표 함수 내의 this를 교체할 수 없다.

이 렉시컬 this때문에 화살표로 메서드를 정의하는 것은 바람직하지 않으며 메서드 축약 표현을 쓰는 것이 바람직하다.

프로퍼티에 화살표 함수를 할당하는 경우도 동일한 문제가 발생한다. 따라서 프로퍼티를 동적 추가할 때는 일반 함수를 할당한다.

일반 함수가 아닌 ES6 메서드를 동적 추가하고 싶을 경우 객체 리터럴을 바인딩하고 constructor를 통해 재정의 한다.

클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다.

- super

super는 내부 슬롯 ``[[HomeObject]]``를 갖는 ES6 메서드 내에서만 사용할 수 있는 키워드이다. 

화살표 함수는 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 상위 스코프의 super를 참조한다.

- arguments

화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 arguments를 참조한다.

따라서 화살표 함수로 가변 인자 함수를 구현하는 경우 rest파라미터를 사용해야 한다.

4. rest 파라미터

- 기본 문법

rest 파라미터(rest parameter, 나머지 매개변수)는 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수이다. rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

rest 파라미터는 할당된 인수를 제외한 인수들을 받는 파라미터이므로 반드시 마지막에 선언되어야 한다.

rest파라미터는 하나만 선언할 수 있다.

rest파라미터는 함수 객체의 length프로퍼티에 영향을 주지 않는다.

- rest 파라미터와 arguments 객체

rest 파라미터가 없는 ES5에서는 arguments객체가 쓰였다. 다만 arguments 객체는 유사 배열 객체이기 때문에 배열 메서드를 사용할 수 없다. 따라서 이를 이용하려면 call을 통해 객체를 배열로 반환해야 했다.

ES6에서 rest파라미터를 통해 넘어온 인수는 배열이기 때문에 이러한 번거로움을 줄일 수 있다.

5. 매개변수 기본값

자바스크립트는 매개변수와 인자의 개수를 검토하지 않는다. 따라서 이로 인한 오류가 발생할 수 있다. 전달되지 않은 매개변수 값은 undefined로 초기화된다. 따라서 이에 대한 방어코드가 필요하다.

ES6에서 도입된 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화할 수 있다. 이 기본값은 매개변수가 undefined로 되었을 때 동작한다.

앞서 살펴본 rest 파라미터에는 기본값을 지정할 수 없다. 매개변수 기본값은 length 프로퍼티와 arguments객체에 아무런 영향을 주지 않는다.



