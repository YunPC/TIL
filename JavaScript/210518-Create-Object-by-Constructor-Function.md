# 생성자 함수에 의한 객체 생성

1. Object 생성자 함수

new 연산자와 함께 Objet 생성자 함수를 사용하여 빈 객체를 생성할 수 있다. 여기에 프로퍼티를 추가하여 객체를 완성할 수 있다. 

생성자 함수란 new 연산자와 함께 객체를 생성하는 함수이다. 이로 인해 생성된 객체를 인스턴스라 한다. Object 외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise를 제공한다. 

객체 리터럴로 객체를 선언하는 방식이 있기 때문에 이 방법은 그다지 유용해 보이지 않는다.

2. 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식의 문제점

프로퍼티가 같은 여러 객체를 만들어야 할 때 불편하다. 객체는 프로퍼티를 통해 상태를 나타낸다. 메서드를 통해 동작을 표현한다. 같은 구조를 여러번 쓰는 것을 방지하기 위해 생성자 함수를 쓴다.

- 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수을 템플릿처럼 사용할 수 있다. this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(self-referencing variable)이다. this가 가리키는 값은 동적으로 결정된다.

|함수 호출 방식|this가 가리키는 값(this 바인딩)|
|--|--|
|일반 함수 호출|전역 객체|
|메서드 호출|메서드를 호출한 객체(마침표 앞에 객체)|
|생성자 함수 호출|생성자 함수가 생성할 인스턴스|

생성자 함수는 특별한 형식이 정해진 것이 아니라 new 연산자와 같이 쓸 경우 생성자 함수로써 동작한다. 만약 new 연산자 없이 사용하는 경우 일반 함수와 같이 동작한다.

- 생성자 함수의 인스턴스 생성 과정

자바스크립트는 생성자 함수 호출 시 암묵적으로 인스턴스를 생성하고 반환한다. 세부적인 과정은 다음과 같다.

+ 인스턴스 생성과 this 바인딩

암묵적으로 빈 객체가 생성된다. 이를 this바인딩을 한다. 이 과정은 함수가 실행되는 런타임 이전에 발생한다.

> 바인딩(binding)
    바인딩이란 식별자와 값을 연결하는 과정을 말한다. this 바인딩은 this와 this가 가리킬 객체를 바인딩한다.

+ 인스턴스 초기화

this에 바인딩되어 있는 인스턴스를 초기화한다. 개발자가 프로퍼티나 메서드를 추가할 수 있다.

+ 인스턴스 반환

인스턴스가 완성되면 바인딩된 this를 반환한다. 만약 명시적으로 객체를 반환하면 암묵적 반환을 무시한다. 원시값을 반환하면 원시값을 무시한다. 제일 좋은 것은 return문을 쓰지 않는 것이다.

- 내부 메서드 `[[Call]]`과 `[[Construct]]`

함수는 객체이므로 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있다.

함수 객체는 일반 객체와 다르게 호출될 수 있다. 따라서 함수 객체만을 위한 내부 슬롯 `[[Environment]]`, `[[FormalParameters]]` 등 과 `[[Call]]`, `[[Construct]]`같은 내부 메서드를 추가로 가지고 있다.

함수가 일반함수로 호출되면 `[[Call]]`메서드가 호출되고 생성자 함수로 호출되면 `[[Construct]]`가 호출된다.

`[[Call]]`을 가지고 있는 함수를 Callable이라 하며, `[[Construct]]`의 유무에 따라 constructor, non-constructor로 나뉜다. 

기본적으로 함수는 호출이 가능하므로 callable이지만 constructor이거나 non-constructor이다. 모든 함수가 생성자 함수는 아니다.

- constructor와 non-constructor의 구분

constructor : 함수 선언문, 함수 표현식, 클래스
non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수

주의할 점은 ECMAScript 사앙에서 메서드로 인정하는 범위가 일반적인 메서드 범위보다 좁다는 점이다.

non-constructor인 함수 객체는 내부 메서드로 ``[[Construct]]``를 갖지 않는다. 따라서 new 연산자를 사용하면 없는 메서드를 호출하기 때문에 에러가 발생한다.

- new.target

생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다. ES6에선 new.target을 지원한다(IE에선 지원하지 않는다.).

new 연산자로 함수 호출을 하면 함수 내부의 new.target은 함수자신을 가리키고 그렇지 않을 시 undefined를 반환한다.

이를 통해 new 연산자를 빠뜨렸을 경우 재귀호출을 통해 new 연산자와 같이 객체를 생성하도록 할 수 있다.

- 스코프 세이프 생성자 패턴(scope-safe constructor)

new.target을 사용할 수 없는 환경에서 사용하는 패턴이다. new 연산자를 통해 생성된 객체는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용하여 new.target과 동일한 코드를 작성할 수 있다. 

대부분의 빌트인 함수는 new 연산자를 빠뜨려도 적절한 값을 반환한다. Object와 Function의 경우 new 연산자의 유무가 동작의 차이를 발생시키지 않는다.

하지만 String, Number, Boolean 생성자 함수는 new가 없을 시 데이터 타입을 변환한다.







