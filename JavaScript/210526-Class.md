# 클래스

1. 클래스는 프로토타입의 문법적 설탕인가?

자바스크립트는 프로토타입 기반 객체지향 언어다. 프로토타입 기반 객체지향 언어는 클래스가 필요 없는(class free) 객체지향 프로그램이 언어다.

이러한 특성은 클래스 기반 개발자에게 장벽으로 느껴진다. 이에 ES6에서 클래스를 추가하였다. 이를 통해 객체 지향에 익숙한 프로그래머가 자바스크립트에 더 빠르게 적응하도록 한다. 

하지만 이는 자바스크립트의 기존 상속 방식을 폐지하는 것이 아니다. 클래스는 함수이고 프로토타입 기반 패턴을 클래스 기반처럼 사용할 수 있게 하는 문법적 설탕이다.

프로토타입을 통한 상속과 완전히 동일하진 않으며 몇 가지 차이점이 있다.

+ 클래스를 new 연산자 없이 호출하면 에러가 발생한다.
+ 클래스는 extends와 super 키워드를 제공한다.
+ 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 클래스도 함수이기 때문에 호이스팅이 발생한다.
+ 클래스의 내부에 있는 코드에 암묵적으로 strict mode가 의무적으로 부여된다.
+ 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 열거되지 않는다.

이러한 차이는 상속관계를 더 명확하게 할 수 있다. 따라서 새로운 객체 생성 메커니즘으로 보는 것이 바람직하다.

2. 클래스 정의

클래스는 class 키워드를 통해 정의하고 파스칼 네이밍으로 이름짓는 것이 일반적이다.

클래스는 표현식으로 쓰일 수 있으며 무명의 리터럴로 작성할 수 있다. 따라서 클래스는 일급 객체이다.

클래스 몸체에서 정의할 수 있는 메서드는 생성자, 프로토타입 메서드, 정적 메서드이다.

3. 클래스 호이스팅

클래스는 함수로 평가된다. 평가된 함수 객체는 생성자 함수로 취급된다. 따라서 프로토타입도 더불어 생성된다. 다만 클래스는 정의 이전에 참조할 수 없다(TDZ 존재).

4. 인스턴스 생성

클래스는 new 연산자와 함께 인스턴스를 생성한다. 이때 new 연산자를 생략하면 에러를 일으킨다. 클래스 표현식으로 정의한 경우 클래스를 가리키는 식별자를 통해 정의해야 한다. 클래스 명으로 선언할 시 에러가 발생한다. 에러가 발생하는 이유는 클래스 명도 내부에서만 유효한 식별자이기 때문이다.

5. 메서드

클래스 몸체에서는 0개 이상의 메서드만 선언할 수 있다. 생성할 수 있는 메서드의 종류로는 생성자, 프로토타입 메서드, 정적 메서드 3가지이다.

> 클래스 정의에 대한 새로운 제안 사항
    2020년 7월 클래스 몸체에 메서드 뿐만 아니라 프로퍼티를 직접 정의할 수 있는 새로운 표준 사양이 제안되었다.

- constructor

생성자는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이다. 이름을 변경할 수 없다.

클래스는 함수 객체로 평가되기 때문에 함수의 프로토타입과 연결되어 있다. 따라서 이 안에 있는 constructor가 클래스를 가리키고 있으므로 생성자 함수임을 알 수 있다. 

생성자 함수이기 떄문에 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.

constructor는 메서드로 해석되지 않는다. constructor의 기술된 동작을 하는 함수 객체가 생성된다.

> 클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티
    클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 직접적인 연관성이 없다. 프로토타입의 constructor 프로퍼티는 생성자 함수를 가리키는 프로퍼티이다.

constructor와 생성자 함수는 차이점이 존재한다.

constructor는 클래스 내에 최대 한 개만 존재할 수 있다. 하지만 필수 요소는 아니다. 만약 constructor를 명시하지 않은 경우 빈 constructor가 암묵적으로 정의된다. 따라서 빈 객체를 생성한다.

constructor를 통해 인스턴스를 초기화하고 싶은 경우 this를 이용하여 프로퍼티를 추가한다. 매개변수를 정할 수도 있다. constructor는 생성자 함수와 동일하게 암묵적으로 this를 반환한다. 만약 return문에 다른 객체를 반환하면 그 객체가 반환된다.

원시값을 반환하는 경우 무시되고 this를 반환한다.

- 프로토타입 메서드

클레스 몸체에서 정의한 메서드는 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다. 클래스는 프로토타입 기반의 객체 생성 매커니즘이다.

- 정적 메서드

클래스에서 메서드에 static 키워드를 붙이면 정적 메서드가 된다. 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다. 정적 메서드는 프로토타입 체인 상에 존재하지 않기 때문에 인스턴스가 상속받을 수 없다.

- 정적 메서드와 프로토타입 메서드의 차이

+ 정적 메서드와 프로토타입 메서드는 서로 다른 스코프 체인에 속해있다.
+ 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
+ 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없고 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

두번째 차이점을 다시 풀어 얘기하면 정적 메서드와 프로토타입 메서드는 this 바인딩이 다르다. 따라서 메서드 내부에서 this를 사용할 필요가 있는 경우 프로토타입 메서드로 정의해야 하며, 없는 경우 정적 메서드로 선언하는 것이 바람직하다. 

정적 메서드로 네임스페이스를 지정할 수 있기 때문에 관련 있는 정적 메서드를 모아두면 충돌 가능성을 줄이고 함수들을 구조화할 수 있다. 

> ES6에 추가된 표준 빌트인 객체 Number의 정적 메서드
    ES6부터 빌트인 전역 함수(isFinite, isNaN, parseFloat, parseInt)가 Number의 정적 메서드로 추가 되었다. 정적 메서드에는 더 엄격한 기준이 적용된다.

- 클래스에서 정의한 메서드의 특징

클래스에서 정의한 메서드의 특징은 다음과 같다.

+ 메서드 축약 표현을 사용한다.
+ 메서드 정의 시 콤마가 필요 없다.
+ 암묵적으로 strict 모드가 실행된다.
+ 프로퍼티 어트리뷰트 `[[Enumerable]]`이 false 값이다.
+ new 연산자와 함께 호출할 수 없다.

6. 클래스의 인스턴스 생성 과정

+ 인스턴스 생성과 this 바인딩

new 연산자와 함께 생성자 함수를 호출하면 평가 이전에 빈 객체를 생성한다. 그리고 이 빈 객체의 프로토타입이 설정되고 이 인스턴스는 this에 바인딩된다.

+ 인스턴스 초기화

constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. constructor 부재 시 이 과정은 생략된다.

+ 인스턴스 반환

클래스의 모든 처리가 끝나면 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.

7. 프로퍼티

- 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야한다. 이 안에 선언된 this는 생성될 인스턴스에만 바인딩된다. 이 프로퍼티는 언제나 publicd이다. 이 사항에 대해 private한 프로퍼티를 정의할 수 있는 사양이 제안 중이다.

- 접근자 프로퍼티

접근자 프로퍼티는 접근자 함수로 구성된 프로퍼티이다. 접근자 프로퍼티는 클래스에서도 사용할 수 있다. 

접근자 함수는 getter와 setter로 이루어져 있다. getter는 값을 얻어올 때 사용한다. 메서드 이름앞에 get을 써줌으로써 사용할 수 있다. setter는 인스턴스 프로퍼티의 값을 조작할 때 사용하고 메서드 앞에 set 키워드를 사용함으로써 setter임을 알린다.

getter와 setter는 프로퍼티를 참조하는 형식으로 사용된다. 그리고 참조시에 getter또는 setter가 호출된다. 

setter는 무언가를 반드시 할당하는 것이므로 반드시 하나의 매개변수를 선언해야 한다.

클래스의 메서드는 기본적으로 프로토타입 메서드가 되므로 프로토타입의 프로퍼티가 된다.

- 클래스 필드 정의 제안

클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티이다. 자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있기 때문에 클래스 필드를 만들 수 없다. 하지만 최신 버전의 브라우저나 node.js에선 문법 에러를 발생시키지 않는다.

이 이유는 클래스 필드 정의 제안이 ECMAScript의 정식 표준 사양으로 승급되지 않았지만, 표준 사양으로 승급될거라 생각해 선제적으로 구현해 놓았기 때문이다. 이 제안은 2021년 5월을 기준으로 stage4에 제안되어 있다.

> Technical Committee 39(TC39)
    ECMAScript의 관리를 담당하는 위원회이다. TC39는 브라우저 벤더와 페이스북, 트위터와 같이 ECMAScript사양을 제대로 준수해야 하는 기업으로 구성되어 있다.

> TC39 프로세스
    TC39 프로세스는 ECMAScript에 새로운 표준 사양을 추가하기 위해 공식적으로 명문화해 놓은 과정이다. 총 5단계로 구성되어 있으며 각 단계마다 승급 조건을 만족하면 다음 단계로 넘어간다. 

클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩하지 않는다. 클래스 필드를 다른 곳에서 참조하는 경우 this를 써야 한다. 클래스 필드의 초기값은 지정하지 않으면 undefined이며 외부 변수로 초기화를 하고 싶다면 constructor를 통해 초기화한다. 

클래스 필드에 함수를 할당하는 경우 이 함수는 인스턴스 메서드가 된다. 따라서 클래스 필드에 함수를 할당하는 것은 바람직하지 않다. 대신 화살표 함수를 할당하여 화살표 함수 내부의 this가 인스턴스를 가리키게 하는 경우가 있다.

- private 필드 정의 제안

자바스크립트는 접근자 키워드를 제공하지 않는다. 하지만 2021년 5월 private 필드를 정의할 수 있는 제안이 stage4에 올라가 있으며 내년에 ECMAScript에 추가될 계획이다.

브라우저나 노드의 최신버전에는 이미 선제적으로 구현되어있다. private필드는  선두에 #을 붙여줌으로써 만들 수 있다.

> 타입스크립트
    자바스크립트의 상위확장이며 접근 제한자를 모두 지원하고 의미 또한 기본적으로 동일하다.

private 필드는 클래스 내부에서만 참조할 수 있다.

|접근 가능성|public|private|
|--|:--:|:--:|
|클래스 내부|O|O|
|자식 클래스 내부|O|X|
|클래스 인스턴스를 통한 접근|O|X|

따라서 private 필드에 접근하기 위해선 접근자 프로퍼티를 통해 접근한다. private 필드는 반드시 클래스 몸체에 정의해야 한다.

- static 필드 정의 제안

클래스 안에 static 필드를 정의하자는 제안이 2021년 5월 기준으로 TC39 프로세서의 stage3 단계에 있다. 

8. 상속에 의한 클래스 확장

- 클래스 상속과 생성자 함수 상속

클래스의 확장은 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의하는 것이다.

클래스에 의한 확장은 상속 해주는 부모 클래스의 속성을 그대로 사용하면서 자신만의 고유한 속성만 추가하여 확장할 수 있다. 상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용하다.

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends를 제공한다. 이를 이용하면 직관적으로 상속을 구현할 수 있다.

- extends 키워드

extends 키워드를 통해 상속을 할때 확장된 클래스를 서브 클래스라고 하고 상속된 클래스를 슈퍼 클래스라 한다. 서브 클래스는 파생 클래스 자식 클래스라 불리기도 한다. 슈퍼 클래스는 베이스 클래스, 부모 클래스라고도 불린다.

extends 키워드도 프로토타입을 통해 상속 관계를 구현한다. 상속 시 클래스 간의 프로토타입 체인도 생성하기 때문에 프로토타입 메서드와 정적 메서드 모두 상속이 가능하다.

- 동적 상속

extends 키워드는 생성자 함수를 상속받을 수 있다 하지만 extends 앞에는 클래스가 와야한다. extends 키워드 다음에는 `[[Construct]]` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식이 올 수 있다.

이를 통해 동적으로 상속받을 함수 객체를 정할 수 있다.

- 서브클래스의 constructor

서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다.

```javascript
constructor(... args){super( ... args);}
```

super()는 수퍼클래스의 constructor를 호출하여 인스턴스를 생성한다.

수퍼클래스와 서브클래스 모두 constructor를 생략하면 빈 객체가 생성된다. 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다.

- super 키워드

super 키워드는 함수로도 쓰일 수 있고 식별자처럼 참조할 수도 있다.

+ super를 호출하면 수퍼클래스의 constructor를 호출한다.
+ super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

`super 호출`

수퍼클래스의 constructor 내부에서 추가한 프로퍼티를 그대로 서브클래스에서 가진다면, 서브 클래스에선 별도의 constructor를 생성하지 않아도 된다.
만약 서브클래스에서 추가 프로퍼티를 갖길 원한다면 constructor를 생성해야한다. 이때 부모 요소와 겹치는 프로퍼티는 super를 호출하여 인수를 전달한다.

super를 호출할 때 주의사항은 다음과 같다.

+ 서브클래스에서 consturctor를 생략하지 않는 경우 서브클래스의 constructor엔 super를 호출해야한다.

+ 서브클래스의 constructor에서 super를 호출하기 전에 this를 참조하면 안된다.

+ super는 반드시 서브클래스의 constructor에서만 호출한다.

`super 참조`

메서드 내에서 super를 참조하면 부모 클래스의 메서드를 호출할 수 있다.
super참조가 동작하기 위해서는 super를 참조하고 있는 메서드의 프로토타입을 찾을 수 있어야 한다. 이를 위해 메서드는 내부 슬롯 `[[HomeObject]]`를 가지며 자신을 바인딩하고 있는 객체를 가리킨다.

이 내부 슬롯은 ES6의 메서드 축약 표현으로 정의된 함수만이 가질 수 있다. super는 비단 클래스의 전유물이 아니라 객체 리터럴에서도 사용할 수 있다.

- 서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킨다.

- 상속 클래스의 인스턴스 생성 과정

+ 서브클래스의 super 호출

자바스크립트 엔진은 클래스 평가시 부모 클래스인지 자식 클래스인지 판별하기 위한 내부 슬롯 `[[ConstructorKind]]`를 갖는다. 부모 클래스라면 "base"로 설정되고 서브클래스는 "derived"로 설정된다. 이 값을 통해 new 연산자와 함께 호출되었을 때 동작이 다르다.

부모 클래스는 new 연산자와 함께 호출되면 인스턴스를 생성하고 이를 this에 바인딩한다.

서서브 클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 

+ 수퍼클래스의 인스턴스 생성과 this 바인딩

수퍼클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체를 생성한다. 이 객체가 바로 인스턴스이다. 암묵적으로 생성된 빈 객체는 this에 바인딩된다. 수퍼클래스의 constructor의 this는 생성할 인스턴스를 가리킨다고 볼 수 있다.

인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다. 따라서 생성된 인스턴스의 프로토타입은 서브클래스의 프로퍼티가 가리키는 객체이다.

+ 수퍼클래스의 인스턴스 초기화

수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 

+ 서브클래스 constructor로의 복귀와 this 바인딩

super가 반환한 인스턴스가 this에 바인딩된다. 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다.

+ 서브클래스의 인스턴스 초기화

+ 인스턴스 반환

- 표준 빌트인 생성자 함수 확장

extends 키워드 다음에는 클래스뿐만 아니라 ``[[Construct]]`` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.

따라서 표준 빌트인 생성자 함수를 상속받아 클래스를 확장하면 그 클래스의 인스턴스는 메서드의 모든 메서드를 사용할 수 있다. 주의할 점은 확장한 메서드로 사용해서 새로운 값을 반환하는 경우 자식 클래스 타입으로 반환하는 점이다. 따라서 원래 빌트인 생성자로 반환하고 싶은 경우 Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가한다. 



